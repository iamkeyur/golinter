// Copyright (c) 2015-2016 The GoAnalysis Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style license that can
// be found in the LICENSE file.
package cfgraph

import (
	"bytes"
	"fmt"
	"github.com/chrisbbe/GoAnalysis/analyzer/globalvars"
	"github.com/chrisbbe/GoAnalysis/analyzer/linter/ccomplexity/bblock"
	"github.com/chrisbbe/GoAnalysis/analyzer/linter/ccomplexity/graph"
	"io"
	"os"
	"os/exec"
	"time"
)

type ControlFlowGraph struct {
	*graph.Graph
}

func New() *ControlFlowGraph {
	return &ControlFlowGraph{graph.NewGraph()}
}

func (controlFlowGraph ControlFlowGraph) Draw(name string) error {
	dottyFile, err := os.Create(name + ".dot")
	if err != nil {
		return err
	}
	defer dottyFile.Close()

	var content bytes.Buffer

	// Write header information.
	content.WriteString("/* --------------------------------------------------- */\n")
	content.WriteString(fmt.Sprintf("/* Generated by %s\n", globalvars.PROGRAM_NAME))
	content.WriteString(fmt.Sprintf("/* Version: %s\n", globalvars.VERSION))
	content.WriteString(fmt.Sprintf("/* Website: %s\n", globalvars.WEBSITE))
	content.WriteString(fmt.Sprintf("/* Date: %s\n", time.Now().String()))
	content.WriteString("/* --------------------------------------------------- */\n")

	// Start writing the graph.
	content.WriteString("digraph ControlFlowGraph {\n")
	content.WriteString("\trankdir=TB;\n")
	content.WriteString("\tnode [shape = doublecircle]; Start Exit;")
	content.WriteString("\tnode [shape = ellipse];")
	for _, node := range controlFlowGraph.Nodes {
		for _, outNode := range node.GetOutNodes() {
			content.WriteString(fmt.Sprintf("\t\"%s\" -> \"%s\";\n", node, outNode))
		}
	}
	content.WriteString("}\n")

	if _, err := io.WriteString(dottyFile, content.String()); err != nil {
		return err
	}
	cmd := exec.Command("dot", "-Tpdf", dottyFile.Name(), "-o", name+".pdf")
	return cmd.Run()
}

// GetControlFlowGraph generates the control flow graph for each function or
// method found in the sequence of basic-blocks. Returning an array of control
// flow graphs where each entry represents an function or method.
func GetControlFlowGraph(basicBlocks []*bblock.BasicBlock) (cfg []*ControlFlowGraph) {
	prevFunctionBlockIndex := -1 // -1 indicates that no FUNCTION_ENTRY has been found.

	//Slicing up basic-blocks containing function or method.
	for index, basicBlock := range basicBlocks {
		if basicBlock.Type == bblock.FUNCTION_ENTRY && prevFunctionBlockIndex == -1 {
			prevFunctionBlockIndex = index //FUNCTION_ENTRY detected, set index.
		} else if basicBlock.Type == bblock.FUNCTION_ENTRY {
			cfg = append(cfg, getControlFlowGraph(basicBlocks[prevFunctionBlockIndex:index]))
			prevFunctionBlockIndex = index // Track which block was the last FUNCTION_ENTRY block.
		}
	}

	if prevFunctionBlockIndex >= 0 {
		cfg = append(cfg, getControlFlowGraph(basicBlocks[prevFunctionBlockIndex:]))
	}
	return
}

// getControlFlowGraph generates and returns the control-flow graph based on the array of basic blocks.
func getControlFlowGraph(basicBlocks []*bblock.BasicBlock) *ControlFlowGraph {
	controlFlowGraph := New()
	var lastBlockAdded *bblock.BasicBlock

	startNode := &graph.Node{Value: bblock.NewBasicBlock(-1, bblock.START, 0)}
	exitNode := &graph.Node{Value: bblock.NewBasicBlock(-1, bblock.EXIT, 0)}

	for _, basicBlock := range basicBlocks {
		lastBlockAdded = basicBlock
		basicBlockNode := &graph.Node{Value: basicBlock}
		controlFlowGraph.InsertNode(basicBlockNode)

		if basicBlock.Type == bblock.RETURN_STMT {
			// RETURN_STMT terminates functior and methods, should therefor always have a edge to EXIT.
			controlFlowGraph.InsertEdge(&graph.Node{Value: basicBlock}, exitNode)
		}

		for _, successorBlock := range basicBlock.GetSuccessorBlocks() {
			controlFlowGraph.InsertEdge(basicBlockNode, &graph.Node{Value: successorBlock})
			lastBlockAdded = successorBlock
		}
	}

	controlFlowGraph.InsertEdge(startNode, controlFlowGraph.Root)
	if lastBlockAdded.Type != bblock.RETURN_STMT {
		// Edge between RETURN_STMT and EXIT is already added higher up!
		controlFlowGraph.InsertEdge(&graph.Node{Value: lastBlockAdded}, exitNode)
	}
	controlFlowGraph.InsertEdge(exitNode, startNode)

	return controlFlowGraph
}
